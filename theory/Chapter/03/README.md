[`홈으로 되돌리기`](/README.md)

또는 아래 원하는 메뉴 선택

|                         |                         |                         |                         |                         |
|:-----------------------:|:-----------------------:|:-----------------------:|:-----------------------:|:-----------------------:|
| [`프로그램의 기본`](/theory/Chapter/01/README.md) | [`데이터형과 변수`](/theory/Chapter/02/README.md) | [`연산자 (현재)`](/theory/Chapter/03/README.md) | [`제어문`](/theory/Chapter/04/README.md) | [`함수`](/theory/Chapter/05/README.md) |
| [`배열`](/theory/Chapter/06/README.md)           | [`포인터`](/theory/Chapter/07/README.md)         | [`문자열`](/theory/Chapter/08/README.md) | [`구조체`](/theory/Chapter/09/README.md) |                         |
|                         |                         |                         |                         |                         |

---
## 연산자
### (1) 수식
수학에서 사용되는 +, -, ×, 〈, 〉, ÷ 기호처럼 프로그래밍에서도 +, -, *, <, >, / 등의 기호로 여러가지 연산에 사용한다. 이처럼 연산에 사용되는 기호를 연산자라 한다. 값이 있는 요소를 **수식**이라 하며, 수식의 값을 구하는 것을 **수식을 평가한다**고 한다.

상수나 변수는 값이 있으므로 수식이다. 연산자와 피연산자 조합으로 만들어진 코드를 **연산식**이라고 한다. 아래 그림과 같이 +은 **연산자**라 하며, 연산자의 대상이 되는 2와 3이 **피연산자**라 한다.

![img](/theory/Chapter/03/image1.jpg "연산자 피연산자 예시")

연산자는 피연산자의 개수에 따라서 단항연산자, 이항연산자, 삼항연산자로 분류할 수 있다.

피연산자의 개수로 분류한 연산자의 종류
| **종류**               | **피연산자의 개수** | **연산자 예시**                              |
|-----------------------|--------------------|------------------------------------------|
| 단항 연산자           | 1                  | `++`, `--`, `!`, `~`, `-`               |
| 이항 연산자           | 2                  | (산술) `+`, `-`, `*`, `/`, `%`                 |
| | 2                  | (대입) `=`, `+=`, `-=`, `*=`, `/=`, `%=`       |
| | 2                  | (관계) `==`, `!=`, `<`, `>`, `<=`, `>=`        |
| | 2                  | (논리) `&&`, `││`                              |
| | 2                  | `(비트) &`, `│`, `^`, `<<`, `>>`               |
| 삼항 연산자           | 3                  | `조건 ? 참일 때 값 : 거짓일 때 값`          |

연산자의 기능에 따라 분류한 연산자의 종류
| **기능**          | **연산자 예시**                          |
|-------------------|---------------------------------------|
| **산술 연산자**    | `+`, `-`, `*`, `/`, `%`              |
| **증감 연산자**    | `++`, `--`                           |
| **관계 연산자**    | `==`, `!=`, `<`, `>`, `<=`, `>=`     |
| **논리 연산자**    | `&&`, `││`, `!`                      |
| **비트 연산자**    | `&`, `│`, `^`, `~`, `<<`, `>>`       |
| **대입 연산자**    | `=`, `+=`, `-=`, `*=`, `/=`, `%=`    |
| **멤버 접근 연산자**| `*x`, `&x`, `x[y]`, `x.y`, `x->y` |
| **그 밖의 연산자**| `x?y:z`, `x,y`, `sizeof(x)`, `(type)x`|

## 연산자의 종류
### (1) 산술 연산자 기본
산술 연산자는 +, -, *, /, % 부호 연산자들이 있다.

| **연산자** | **의미**         | **사용 예**    | **연산 결과**    |
|------------|------------------|----------------|------------------|
| `+`        | 덧셈             | `3 + 2`        | `5`              |
| `-`        | 뺄셈             | `5 - 3`        | `2`              |
| `*`        | 곱셈             | `4 * 2`        | `8`              |
| `/`        | 나눗셈           | `10 / 2`       | `5`              |
| `%`        | 나머지 계산       | `10 % 3`       | `1`              |

산술 연산자 중 부호 연산자인 +와 0는 단항 연산자이다.
```c
#include <stdio.h>

int main() {
    int num = 123;
    printf("%d", -num);
}

// 출력 : 
// -123
```
산술 연산자는 정수와 실수에 대해서 사용할 수 없다. 참고로 "정수/정수" 연산의 결과는 정수이다. 나머지 연산자(%)는 피연산자가 모두 정수인 경우에만 사용할 수 없다.

### (2) 피연산자의 형 변환
이항 연산자를 사용하는 연산식에서 피연산자의 데이터형이 서로 다르면 피연산자를 같은 형으로 변환한 다음 연산을 수행한다. 이떄. 피연산자 중 하나가 실수형이면 실수형으로 형 변환한다. 이러한 형 변환을 **정수의 승격**이라 한다.
```c
#include <stdio.h>

int main() {
    int num = 3000000;
    printf("%f", 0.35 * num);
}

// 출력 : 
// 1050000.000000
```
### (3) 증감 연산자
증감 연산자는 변수의 값을 1만큼 증가/감솔시키는 단항 연산자이다.

```c
int count = 0;
++count;
10++; // 10++ 상수이므로 ++ 연산자 사용할 수 없다.
(count+1)--; // (count+1)-- 수식이므로 -- 연산자 사용 X 
```
증감 연산자는 전위형 또는 후위형으로 사용될 수 있다. 전위형은 증감 연산자를 피연산자 앞에 사용하고, 후위형은 증감 연산자를 피연산자의 뒤에 사용한다.
```c
#include <stdio.h>

int main() {
    int oranges = 10;

    printf("전위형 (++oranges): %d\n", ++oranges);

    oranges = 10; // 초기화
    printf("후위형 (oranges++): %d\n", oranges++); // 현재 값 출력: 10
    printf("후위형 증가 후 oranges: %d\n", oranges); // 증가 후 값 확인: 11

    return 0;
}

// 출력 :
// 전위형 (++oranges): 11
// 후위형 (oranges++): 10
// 후위형 증가 후 oranges: 11
```
전위형을 사용하면 먼저 변수의 값을 1을 증가/감소시킨 후, 변수의 값이 연산의 결과가 된다. 후위형을 사용하면 1을 증가/감소 되기 전 변수의 값이 연산의 결과가 된 후 다음 문장으로 넘어가기 전 변수가 증가/감소된다.

### (4) 대입 연산자
대입 연산자는 좌변에 있는 변수에 우변의 값을 저장한다.
```c
#include <stdio.h>

int main() {
    int a = 5, b = 10;
    total = a + b; // 대입 연산
    printf("a의 값: %d\n", total);
    return 0;
}
//출력 :
//a의 값: 15
```
대입 연산자의 좌변에는 Lvalue만 사용할 수 있다. Lvalue는 메모리 주소가 있어서 변경할 수 있는 요소이다. 메모리에서 할당되는 변수가 바로 Lvalue이다. 대입 연산자의 우변에는 수식 사용할 수 있다. Lvalue와 비교해서 값이 있는 수식을 Rvalue라 한다.

### (5) 복합 대입 연산자
복합 대입 연산자는 산술/비트 연산자와 대입 연산자를 결합한 것이다. 복합 대입 연산자는 아래처럼 두 식은 같은 식이다.

`total = total + 1` == `total += 1`

| **연산자** | **의미**                            | **사용 예**         | **결과**             |
|------------|----------------------------------|--------------------|------------------|
| `+=`       | 왼쪽 변수에 오른쪽 값을 더하고 결과를 저장 | `a += b`           | `a = a + b`      |
| `-=`       | 왼쪽 변수에서 오른쪽 값을 빼고 결과를 저장 | `a -= b`           | `a = a - b`      |
| `*=`       | 왼쪽 변수에 오른쪽 값을 곱하고 결과를 저장 | `a *= b`           | `a = a * b`      |
| `/=`       | 왼쪽 변수를 오른쪽 값으로 나누고 결과를 저장 | `a /= b`           | `a = a / b`      |
| `%=`       | 왼쪽 변수를 오른쪽 값으로 나눈 나머지를 저장 | `a %= b`           | `a = a % b`      |
| `^=`       | 왼쪽 변수와 오른쪽 값을 비트 XOR하여 결과를 저장 | `a ^= b`           | `a = a ^ b`      |
| `<<=`      | 왼쪽 변수의 비트를 오른쪽 값만큼 왼쪽으로 이동 후 저장 | `a <<= b`          | `a = a << b`     |
| `>>=`      | 왼쪽 변수의 비트를 오른쪽 값만큼 오른쪽으로 이동 후 저장 | `a >>= b`          | `a = a >> b`     |
| `&=`       | 왼쪽 변수와 오른쪽 값을 비트 AND하여 결과를 저장 | `a &= b`           | `a = a & b`      |
| `│=`       | 왼쪽 변수와 오른쪽 값을 비트 OR하여 결과를 저장 | `a │= b`           | `a = a │ b`      |

```c
#include <stdio.h>

int main() {
    int a = 5, b = 10;
    a += b;
    printf("a의 값: %d\n", a); // 출력: 15
    return 0;
}
```
### (5) 관계 연산자
관계 연산자는 두 수를 비교하기 위한 연산자이다. "x와 y가 같은가?"라는 질문의 닶이 "예/아니요"인 것처럼 관계 연산식의 값은 항상 참 또는 거짓이 된다. 프로그래밍 언어에서는 1은 참이고 0은 거짓이다. 즉 관계 연산식의 값은 항상 0 또는 1이다. 관계 연산식은 if문, for문, while문 등 조건식으로 주로 사용된다.

| **연산자** | **의미**                     | **사용 예**    | **결과**               |
|------------|-----------------------------|----------------|-----------------------|
| `==`       | 두 값이 같은지 비교           | `5 == 5`       | 참 (`1`)            |
| `!=`       | 두 값이 다른지 비교           | `5 != 3`       | 참 (`1`)            |
| `<`        | 왼쪽 값이 오른쪽 값보다 작은지 비교 | `3 < 5`        | 참 (`1`)            |
| `>`        | 왼쪽 값이 오른쪽 값보다 큰지 비교 | `5 > 3`        | 참 (`1`)            |
| `<=`       | 왼쪽 값이 오른쪽 값보다 작거나 같은지 비교 | `5 <= 5`       | 참 (`1`)            |
| `>=`       | 왼쪽 값이 오른쪽 값보다 크거나 같은지 비교 | `5 >= 3`       | 참 (`1`)            |

#### 주의사항  - 관계 연산식을 조합할떄는 논리 연산자를 함께 사용한다.
관계 연산자는 이항 연산자이므로 한 번에 2개의 값만 비교할 수 있다. 2개 이상의 수식을 사용할려면 논리 연산자를 사용해야 한다.

`90 <= score <= 100` - 잘못된 수식

`90 <= score && score <= 100` - 올바른 수식

### (6) 논리 연산자
논리 연산자는 참/거짓을 이용한 논리 연산 기능을 제공한다. 논리 연산자로는 이항 연산자인 &&, ││ 와 단항 연산자인 !이 있다. 논리 연산자는 관계 연산자와 함께 사용되는 경우가 많다. 

| **연산자** | **의미**                         | **사용 예**         | **결과**              |
|------------|--------------------------------|--------------------|--------------------|
| `&&`       | 논리 AND (둘 다 참일 때 참)         | `(5 > 3) && (2 < 4)` | 참 (`1`)         |
| `││`       | 논리 OR (하나라도 참일 때 참)        | `(5 > 3) ││ (2 > 4)` | 참 (`1`)         |
| `!`        | 논리 NOT (값을 반대로 뒤집음)        | `!(5 > 3)`          | 거짓 (`0`)      |

#### 주의사항 1 - !연산은 관계 연산보다 먼저 수행한다.
#### 주의사항 2 - &&연산이 ││보다 먼저 실행한다.

### (7) 비트 연산자
비트 연산자는 피연산자의 각 비트 단위로 연산을 수행한다. 예를 들어 피연산자가 5바이트 크기의 int형이면 4바이트 정수값에 대한 연산을 수행하는 것이 아니라 32비트의 2진 데이터 비트들에 대한 연산을 수행한다. **비트 연산자는 피연산자로 정수형만 사용할 수 있다.**

| **연산자** | **의미**                            | **사용 예**         | **결과**                         |
|------------|----------------------------------|--------------------|--------------------------------|
| `&`        | 비트 AND (두 비트가 모두 1일 때 1)   | `5 & 3`            | 두 값의 비트 AND 결과 (`1`)       |
| `│`        | 비트 OR (하나라도 1일 때 1)          | `5 │ 3`            | 두 값의 비트 OR 결과 (`7`)        |
| `^`        | 비트 XOR (둘이 다를 때 1)           | `5 ^ 3`            | 두 값의 비트 XOR 결과 (`6`)       |
| `~`        | 비트 NOT (비트를 반전)               | `~5`               | 5의 비트 반전 결과 (`-6`)         |
| `<<`       | 비트 왼쪽 시프트 (비트를 왼쪽으로 이동) | `5 << 1`           | 5의 비트를 왼쪽으로 1칸 이동 (`10`) |
| `>>`       | 비트 오른쪽 시프트 (비트를 오른쪽으로 이동) | `5 >> 1`           | 5의 비트를 오른쪽으로 1칸 이동 (`2`) |

`>>`는 연사자는 비트를 왼른쪽로 이동시킨다. 그떄 밀려난 비트는 사라지고 빈 자리를 부호 비트로 채운다. 즉 양수는 0, 음수는 1로 채운다.
즉 **n비트 오른쪽 이동은 2ⁿ으로 나눈 것과 같다.**
![img](/theory/Chapter/03/image2-1.png "비트 연산자 예시")

`<<`연산자는 비트를 왼쪽으로 이동시킨다. 이때 왼쪽으로 밀려난 비트는 사라지고 오른쪽 빈 자리를 0으로 채운다. 왼쪽으로 1만큼 이동하면 값이 2배가 된다. **즉 n비트 왼쪽 이동은 2ⁿ을 곱하는 것과 같다.**
![img](/theory/Chapter/03/image2.png "비트 연산자 예시")

### (8) 조건 연산자
조건 연산자는 피연산자가 3개인 삼향 연산자이다. 조건 연산자를 사용하는 형식과 예시는 다음과 같다.

`a (연산자) b ? c : d `
```c
#include <stdio.h>

int main() {
    int age = 20;

    // 조건 연산자를 사용하여 메시지 설정
    const char* message = (age >= 18) ? "성인입니다." : "미성년자입니다.";
    printf("결과: %s\n", message);

    return 0;
}
// 출력:
// 결과: 성인입니다.
```
`(age >= 18) ? "성인입니다." : "미성년자입니다.";` 에서 `(age >= 18)`가 참이면 `"성인입니다."`가 연산의 결과가 된다. 거짓이 될경우 `"미성년자입니다."`가 연산의 결과가 된다.

### (9) 연산자의 우선순위

| **우선순위** | **연산자**                                      | **결합 방향**       |
|--------------|------------------------------------------------|-------------------|
| 1            | `()` (괄호), `[]`, `->`, `.`                   | 왼쪽에서 오른쪽으로 |
| 2            | `++`, `--`, `!`, `~`, `(형변환)`, `*` (포인터), `&` (주소), `sizeof` | 오른쪽에서 왼쪽으로 |
| 3            | `*`, `/`, `%`                                  | 왼쪽에서 오른쪽으로 |
| 4            | `+`, `-`                                       | 왼쪽에서 오른쪽으로 |
| 5            | `<<`, `>>`                                     | 왼쪽에서 오른쪽으로 |
| 6            | `<`, `<=`, `>`, `>=`                           | 왼쪽에서 오른쪽으로 |
| 7            | `==`, `!=`                                     | 왼쪽에서 오른쪽으로 |
| 8            | `&`                                            | 왼쪽에서 오른쪽으로 |
| 9            | `^`                                            | 왼쪽에서 오른쪽으로 |
| 10           | `│`                                            | 왼쪽에서 오른쪽으로 |
| 11           | `&&`                                           | 왼쪽에서 오른쪽으로 |
| 12           | `││`                                           | 왼쪽에서 오른쪽으로 |
| 13           | `?:`                                           | 오른쪽에서 왼쪽으로 |
| 14           | `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `│=`, `^=`, `<<=`, `>>=` | 오른쪽에서 왼쪽으로 |
| 15           | `,` (콤마)                                     | 왼쪽에서 오른쪽으로 |

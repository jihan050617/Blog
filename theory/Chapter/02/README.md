# 데이터형과 변수
**데이터형**

C언어는 데이터의 종류를 구분해서 사용할 수 있도록 데이터형을 제공한다. 데이터의 종류(데이터형)에 따라서 데이터를 저장하는 데 메모리가 얼마나 필요한지, 데이터를 어떤 방식으로 표현하고 저장하는지가 결정된다.

컴퓨터 시스템에서는 모든 데이터가 0과 1 즉 이진 데이터로 표현되며 저장된다. 프로그램에서 사용되는 변수나 상수값도 마찬가지이다. 소스 코드에서는 10진수나 16진수를 사용하더라도 컴파일 결과로 셍성되는 기계어 코드에서는 2진 데이터를 사용한다. 이처럼 컴퓨터 시스템에서 2진 데이터로 값을 표현하고 저장하는 방식을 **데이터의 2진 표현**이라고 한다.

![img](/theory/Chapter/02/image1.png "데이터의 2진 표현 예시")
---
**(1) 기본 데이터형**

C언어의 데이터형은 크게 **기본 데이터형, 파생 데이터형, 사용자 정의형**으로 구분할 수 있다. 

**기본 데이터형**은 C언어 자체에서 기본 제공하는 문자형인 char 정수형인 short, int, long, long long 실수형인 float, double, long double 등 있다.

**정수형의 부호 있는 정수형(signed)과 부호 없는 정수형(unsigned)**
| 데이터 형           | 크기        | 유효 범위                            |
|---------------------|:-----------:|--------------------------------------|
| `char`             | 1 Byte      | -128 ~ 127                          |
| `unsigned char`    | 1 Byte      | 0 ~ 255                             |
| `short`            | 2 Bytes     | -32,768 ~ 32,767                    |
| `unsigned short`   | 2 Bytes     | 0 ~ 65,535                          |
| `int`              | 4 Bytes     | -2,147,483,648 ~ 2,147,483,647      |
| `unsigned int`     | 4 Bytes     | 0 ~ 4,294,967,295                   |
| `long`             | 4 Bytes     | -2,147,483,648 ~ 2,147,483,647      |
| `unsigned long`    | 4 Bytes     | 0 ~ 4,294,967,295                   |
| `long long`        | 8 Bytes     | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |
| `unsigned long long` | 8 Bytes   | 0 ~ 18,446,744,073,709,551,615      |
| `float`            | 4 Bytes     | 약 ±3.4E-38 ~ ±3.4E+38              |
| `double`           | 8 Bytes     | 약 ±1.7E-308 ~ ±1.7E+308            |
| `long double`      | 12 또는 16 Bytes | 구현에 따라 다름 (예: ±3.4E-4932 ~ ±1.1E+4932) |

**파생 데이터형**은 배열, 포인터처럼 기본형으로 부터 파생된 데이터형이다.

**사용자 정의형**은 구조체, 공용체, 열거체처럼 프로그래머에 의해서 만들어진 데이터형이다.

**(2) 정수의 2진 표현**

부호 있는 정수형은 최상위 비트를 부호 비트로 사용한다. 즉 부호 비트가 1이면 음수, 0이면 양수이다. 컴퓨터 시스템에서는 음수를 나타내기 위해 2의 보수를 사용한다. -n을 2의 보수로 표현할려면 먼저 n을 2진수로 나타낸 다음 각 비트를 0은 1로, 1은 0으로 반전시키고(1의 보수) 그 결과에서 1을 더한다

![img](/theory/Chapter/02/image2.png "정수의 2진 표현 예시")

```c
// 부호있는 정수와 부호 없는 정수
#include <stdio.h>

int main() {
    // 부호 있는 short 형 변수
    short x = -7; 
    // 부호 없는 short 형 변수
    unsigned short y = 65529; 
    printf("x = %5d %08x\n", x, x);
    printf("y = %5d %08x\n", y, y);
    return 0;
}

// 출력 : 
// x =    -7 FFFFFFF9
// y = 65529 0000FFF9
```

출력 결과 분석
- x의 출력:- x 값은 -7이며, 메모리에는 16진수로 2의 보수로 저장된다.
- -7의 2의 보수 표현은 16비트로 표현하면: 1111111111111001.
- 이를 16진수로 변환하면: FFF9.
- 따라서 출력 결과는:x =    -7 FFFFFFF9
여기서 FFFFFFF9는 -7의 값을 32비트로 확장한 것이다.

- y의 출력:- y 값은 부호 없는 short 형으로 저장되며, 값이 65529이다.
- 이를 16진수로 변환하면:- 16비트로 표현하면: 1111111111111001.
- 이를 16진수로 변환하면: FFF9.
- y는 부호가 없으므로, 32비트로 확장할 경우 앞자리에 0이 추가된다. :y = 65529 0000FFF9

**(3) 정수형으로 사용되는 char형**

char형은 문자형이지만 1바이트 크기의 정수형으로도 사용될 수 있다.
```c
#include <stdio.h>

int main() {
    char a = 65; // 정수 65를 저장 (ASCII 코드로 'A')
    char b = a+1;
    printf("a = %d, 문자로 표현: %c\n", a, a);
    printf("b = %d, 문자로 표현: %c\n", b, b);
    return 0;
}
// 출력 :
// a = 65, 문자로 표현: A
// b = 66, 문자로 표현: B
```
**(4) 정수형의 유효 범위**

정수형 크기에 따라 표현 가능한 정수의 범위가 달라진다. 유효 범위가 초과되면 오버플로우가 발생한다.
```c
#include <stdio.h>

int main() {
    char a = 128; //char의 유효범위는 -128 ~ 127이며 128은 초과범위이다.
    unsigned char red = 256; // unsigned char 유효범위는 0~255이다 300은 초과범위이다.
    printf("a = %d\n", a); // 오버플로우
    printf("red = %d\n", red);
    return 0;
}
// 출력 :
// a = -128
// red = 0
```
![img](/theory/Chapter/02/image3.png "정수형의 유효 범위 예시")

---
**문자형**

**(1) 문자 2진 표현**

문자를 2진 데이터로 나타내기 위해서 각 문자에 대응되는 문자 코드를 사용한다. 문자 코드로는 ASCII(아스키) 코드, EBCDIC코드, 한글 완성형 코드등 있으며 ASCII 코드가 가장 기본적인 문자다.

![img](/theory/Chapter/02/image4.gif "데이터의 2진 표현 예시 : 아스키 코드")

예를 들어 char형의 변수에 'A'문자를 저장하면 실제로는 'A'문자의 아스키 코드인 65(0x41)가 저장된다. A -> 65(0x41) [char = DEX(0XHEX)]

```c
#include <stdio.h>

int main() {
    char input;
    printf("문자를 입력하세요: ");
    scanf("%c", &input);
    printf("입력된 문자: %c\n", input);
    printf("문자의 ASCII 코드: %#02x\n", input); // 아스키코드 출력 (0x와 함께 16진수 출력)
    return 0;
}
// 출력 :
// 문자를 입력하세요.
// M
// 입력된 문자 : M
// 문자의 ASCII 코드: 0x4d
```

**(2) 이스케이프 스퀀스**

아스키 코드 중 제어 문자는 출력할 수 없는 문자로 ㄹ프린터 등의 장치를 제어하기 위해서 사용된다. 제어 문자는 출력할 수 없기에 아스키코드를 직접 사용하거나 이스케이프 스퀀스로 나타낸다. 이스케이프 스퀀스는 " " 안에 역슬래시와 정해진 문자를 사용한다.

![img](/theory/Chapter/02/image5.png "이스케이프 스퀀스")

---
**실수형**

**(1)실수의 2진 표현**
컴퓨터 시스템에서는 실수를 부동소수점방식으로 표현한다. 부동소수점 방식은 실수를 지수 부분과 가수 부분으로 나누어 2진 데이터로 저장한다.

부동소수점 방식에서 값의 여러 가지 표현되는 것을 막기 위해서 실수를 1.xxxX2의 n승로 나타낸다. 이때 가수 부분인 1.xxx중 xxx와 지수 부분인 2의 n승중 n은 2진수로 표현된다. **부동 소수점으로 표현된 실수의 정밀도는 실수의 가수부분에 의해서 결정되고, 실수의 범위는 지수 부분에 의해 결정된다.**
실수의 정밀도에는 단정도와 배정도가 있다. 단정도 실수를 나타낼때는 float형을 사용하고 배정도 실수를 나타낼 때는 double형을 사용한다.

**(2)실수형의 유효 범위**

실수형에 대해서도 오버플로우가 발생할 수 있다. 실수형 변수에 표현 가능한 최대값보다 큰 값을 저장하려고 하면 무한대를 의미하는 INF로 설정된다. 또 실수형 변수에 표현 가능한 최소값보다 작은 값을 저장하려고 하면, 가수부분을 줄이고 지수 부분을 늘려서 실수를 표현하거나, 만일 그것이 불가능해지면 0으로 만들어 버린다. 이것을 **언더플로우**라 한다.

---

**변수의 선언**

변수를 사용하기 위해서 컴파일러에게 변수의 데이터형과 변수 이름을 알려주는 것을 변수의 선언이라고 한다.

```c
int num = 0; // 변수 선언, = 다음은 변수 초기값을 써주면 변수의 초기화이다.
double height, weight; // 변수를 여러 개 선언할 때 ,를 사용한다.
```
```c
int num; // 변수를 초기화하지 않으면 쓰레기 값을 가진다. 
printf("%d", num); // 변수의 값을 읽어오거나 변경하려면 변수 이름을 이용한다.(대입)
```
```c
int num;
num = 12.3; // 데이터형이 맞지않으면 데이터 손실이 일어난다.
```
```markdown
- 식별자를 만드는 규칙
    1. 반드시 영문자, 숫자, 밑줄 기호만 사용해야한다.
    2. 첫 글자는 반드시 영묹 또는 밑줄 기호로 시작해야한다.
    3. 밑줄 기호 외에는 다른 기호 사용할 수 없다.
    4. 대소문자 구분해서 만들어야한다.
    5. c언어의 키워드는 식별자로 사용할 수 없다.
```

---
**상수**

상수는 프로그램에서 값이 변경되지 않는 요소이다. 상수는 값이 메모리에 저장되지 않고, 한 번만 사용된 다음 없어져 버리는 임시값이다. 상수에는 값을 직접 사용하는 리터럴 상수와 이름이 있는 기호 상수가 있다.

**(1) 리터럴 상수**

소스 코드에서 직접 사용되는 값을 리터럴 상수라 한다.

| **상수의 종류** | **구분** | **예** | **데이터형** |
|----------------|---------|--------|-------------|
| **문자형 상수** | 일반 문자 | `'x'`, `'y'` | `int` |
|  | 이스케이프 시퀀스 | `'\\b'`, `'\\t'`, `'\\xa'` | `int` |
| **정수형 상수** | 10진수 정수 | `-10`, `10` | `int` |
|  | 16진수 정수 | `0xa`, `0XA` | `int` |
|  | 8진수 정수 | `012` | `int` |
|  | unsigned형 정수 | `65535u`, `65535U` | `unsigned int` |
| **정수형 상수** | long형 정수 | `2147483647L`, `2147483647l` | `long` |
|  | unsigned long형 정수 | `2147483647UL`, `2147483647ul` | `unsigned long` |
| **실수형 상수** | 부동소수점 표시 실수 | `56.78`, `.5` | `double` |
|  | 지수 표시 실수 | `5.678e1`, `.5e0` | `double` |
|  | float형 실수 | `0.25f`, `0.25F` | `float` |
|  | 문자열 상수 | `"x"`, `"x"` | `char[ ]` |

**(2) 매크로 상수**

메크로 상수는 #define문으로 정의되는 상수이다. 프로그램에서 여러 번 사용되는 상수 값은 매크로 상수로 정의하면 편하다. 또한 #으로 시작하는 문장은 전처리기 문장이다. 즉 #include문과 #define은 C문장이 아니다. 전처리기는 #define으로 정의된 매크로 상수를 특정 값으로 대치한다.
```c
#include <stdio.h>

#define PI 3.141592653589793 // 매크로 상수로 파이 정의

int main() {
    double radius, area;
    printf("원의 반지름을 입력하세요: ");
    scanf("%lf", &radius); // 반지름 입력
    area = PI * radius * radius; // 원의 넓이 계산
    printf("반지름 %.2f인 원의 넓이: %.5f\n", radius, area);
    return 0;
}
// 출력:
// 원의 반지름을 입력하세요: 5
// 반지름 5.00인 원의 넓이: 78.53982
```
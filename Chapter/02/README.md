# 프로그램 기본
**데이터형**

C언어는 데이터의 종류를 구분해서 사용할 수 있도록 데이터형을 제공한다. 데이터의 종류(데이터형)에 따라서 데이터를 저장하는 데 메모리가 얼마나 필요한지, 데이터를 어떤 방식으로 표현하고 저장하는지가 결정된다.

컴퓨터 시스템에서는 모든 데이터가 0과 1 즉 이진 데이터로 표현되며 저장된다. 프로그램에서 사용되는 변수나 상수값도 마찬가지이다. 소스 코드에서는 10진수나 16진수를 사용하더라도 컴파일 결과로 셍성되는 기계어 코드에서는 2진 데이터를 사용한다. 이처럼 컴퓨터 시스템에서 2진 데이터로 값을 표현하고 저장하는 방식을 **데이터의 2진 표현**이라고 한다.

![img](/Chapter/02/image1.png "데이터의 2진 표현 예시")
---
**(1) 기본 데이터형**

C언어의 데이터형은 크게 **기본 데이터형, 파생 데이터형, 사용자 정의형**으로 구분할 수 있다. 

**기본 데이터형****은 C언어 자체에서 기본 제공하는 문자형인 char 정수형인 short, int, long, long long 실수형인 float, double, long double 등 있다.

**정수형의 부호 있는 정수형(signed)과 부호 없는 정수형(unsigned)**
| 데이터 형           | 크기        | 유효 범위                            |
|---------------------|:-----------:|--------------------------------------|
| `char`             | 1 Byte      | -128 ~ 127                          |
| `unsigned char`    | 1 Byte      | 0 ~ 255                             |
| `short`            | 2 Bytes     | -32,768 ~ 32,767                    |
| `unsigned short`   | 2 Bytes     | 0 ~ 65,535                          |
| `int`              | 4 Bytes     | -2,147,483,648 ~ 2,147,483,647      |
| `unsigned int`     | 4 Bytes     | 0 ~ 4,294,967,295                   |
| `long`             | 4 Bytes     | -2,147,483,648 ~ 2,147,483,647      |
| `unsigned long`    | 4 Bytes     | 0 ~ 4,294,967,295                   |
| `long long`        | 8 Bytes     | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |
| `unsigned long long` | 8 Bytes   | 0 ~ 18,446,744,073,709,551,615      |
| `float`            | 4 Bytes     | 약 ±3.4E-38 ~ ±3.4E+38              |
| `double`           | 8 Bytes     | 약 ±1.7E-308 ~ ±1.7E+308            |
| `long double`      | 12 또는 16 Bytes | 구현에 따라 다름 (예: ±3.4E-4932 ~ ±1.1E+4932) |

**파생 데이터형**은 배열, 포인터처럼 기본형으로 부터 파생된 데이터형이다.

**사용자 정의형**은 구조체, 공용체, 열거체처럼 프로그래머에 의해서 만들어진 데이터형이다.

---
**(2) 정수의 2진 표현**

부호 있는 정수형은 최상위 비트를 부호 비트로 사용한다. 즉 부호 비트가 1이면 음수, 0이면 양수이다. 컴퓨터 시스템에서는 음수를 나타내기 위해 2의 보수를 사용한다. -n을 2의 보수로 표현할려면 먼저 n을 2진수로 나타낸 다음 각 비트를 0은 1로, 1은 0으로 반전시키고(1의 보수) 그 결과에서 1을 더한다

![img](/Chapter/02/image2.png "정수의 2진 표현 예시")

```c
// 부호있는 정수와 부호 없는 정수
#include <stdio.h>

int main() {
    // 부호 있는 short 형 변수
    short x = -7; 
    // 부호 없는 short 형 변수
    unsigned short y = 65529; 
    printf("x = %5d %08x\n", x, x);
    printf("y = %5d %08x\n", y, y);
    return 0;
}

// 출력 : 
// x =    -7 FFFFFFF9
// y = 65529 0000FFF9
```

출력 결과 분석
- x의 출력:- x 값은 -7이며, 메모리에는 16진수로 2의 보수로 저장된다.
- -7의 2의 보수 표현은 16비트로 표현하면: 1111111111111001.
- 이를 16진수로 변환하면: FFF9.
- 따라서 출력 결과는:x =    -7 FFFFFFF9
여기서 FFFFFFF9는 -7의 값을 32비트로 확장한 것이다.

- y의 출력:- y 값은 부호 없는 short 형으로 저장되며, 값이 65529이다.
- 이를 16진수로 변환하면:- 16비트로 표현하면: 1111111111111001.
- 이를 16진수로 변환하면: FFF9.
- y는 부호가 없으므로, 32비트로 확장할 경우 앞자리에 0이 추가된다. :y = 65529 0000FFF9

---
**(3) 정수형으로 사용되는 char형**

char형은 문자형이지만 1바이트 크기의 정수형으로도 사용될 수 있다.
```c
#include <stdio.h>

int main() {
    char a = 65; // 정수 65를 저장 (ASCII 코드로 'A')
    char b = a+1;
    printf("a = %d, 문자로 표현: %c\n", a, a);
    printf("b = %d, 문자로 표현: %c\n", b, b);
    return 0;
}
// 출력 :
// a = 65, 문자로 표현: A
// b = 66, 문자로 표현: B
```
---
**(4) 정수형의 유효 범위**

정수형 크기에 따라 표현 가능한 정수의 범위가 달라진다. 유효 범위가 초과되면 오버플로우가 발생한다.
```c
#include <stdio.h>

int main() {
    char a = 128; //char의 유효범위는 -128 ~ 127이며 128은 초과범위이다.
    unsigned char red = 300; // unsigned char 유효범위는 0~255이다 300은 초과범위이다.
    printf("a = %d\n", a);
    printf("red = %d\n", red);
    return 0;
}
// 출력 :
// a = -128
// red = 44
```